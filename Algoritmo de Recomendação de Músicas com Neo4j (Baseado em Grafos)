### **Algoritmo de RecomendaÃ§Ã£o de MÃºsicas com Neo4j (Baseado em Grafos)**  
Este algoritmo combina **filtragem colaborativa** e **recomendaÃ§Ã£o baseada em conteÃºdo** usando a estrutura de grafos do Neo4j. Inclui tratamento para *cold start* e exemplos de consultas Cypher/GDS.

---

#### **1. Modelo de Dados no Neo4j**  
Estrutura bÃ¡sica de nÃ³s e relacionamentos:  
```cypher
// NÃ³s
CREATE (:User {id: "user123", name: "Alice"});
CREATE (:Song {id: "song456", title: "Midnight Memories"});
CREATE (:Artist {id: "artist789", name: "Taylor Echo"});
CREATE (:Genre {id: "genre001", name: "Pop"});

// Relacionamentos com propriedades
MATCH (u:User {id: "user123"}), (s:Song {id: "song456"})
CREATE (u)-[:LISTENED_TO {count: 5, lastListen: datetime("2026-01-03T12:00:00")}]->(s);

MATCH (s:Song {id: "song456"}), (a:Artist {id: "artist789"})
CREATE (s)-[:CREATED_BY]->(a);

MATCH (s:Song {id: "song456"}), (g:Genre {id: "genre001"})
CREATE (s)-[:BELONGS_TO]->(g);
```

---

#### **2. EstratÃ©gias de RecomendaÃ§Ã£o**  
##### **A. Filtragem Colaborativa (UsuÃ¡rios Similares)**  
Encontra usuÃ¡rios com gostos similares e recomenda mÃºsicas que eles ouviram, mas o usuÃ¡rio-alvo nÃ£o.  
**Exemplo com GDS (Node Similarity):**  
```cypher
// Projeta grafo para anÃ¡lise
CALL gds.graph.project(
  "collabGraph",
  ["User", "Song"],
  { LISTENED_TO: { properties: "count" } }
);

// Calcula similaridade entre usuÃ¡rios
CALL gds.nodeSimilarity.stream("collabGraph", {
  similarityCutoff: 0.1,
  topK: 10
})
YIELD node1, node2, similarity
WHERE gds.util.asNode(node1).id = "user123"
WITH gds.util.asNode(node2) AS similarUser, similarity
MATCH (similarUser)-[r:LISTENED_TO]->(s:Song)
WHERE NOT (gds.util.asNode(node1))-[:LISTENED_TO]->(s)
RETURN s.title AS recommendation, SUM(r.count * similarity) AS score
ORDER BY score DESC
LIMIT 10;
```

##### **B. Baseado em ConteÃºdo (GÃªnero/Artista)**  
Recomenda mÃºsicas do mesmo gÃªnero ou artista das mÃºsicas jÃ¡ ouvidas pelo usuÃ¡rio.  
**Exemplo em Cypher:**  
```cypher
MATCH (u:User {id: "user123"})-[l:LISTENED_TO]->(s:Song)-[:BELONGS_TO]->(g:Genre)
WITH u, g, SUM(l.count) AS genreAffinity
ORDER BY genreAffinity DESC
LIMIT 3 // Top 3 gÃªneros

MATCH (g)<-[:BELONGS_TO]-(rec:Song)
WHERE NOT (u)-[:LISTENED_TO]->(rec)
RETURN rec.title AS recommendation, genreAffinity AS score
ORDER BY score DESC
LIMIT 10;
```

##### **C. Abordagem HÃ­brida (CombinaÃ§Ã£o Ponderada)**  
Combina scores de filtragem colaborativa e conteÃºdo:  
```cypher
// Score colaborativo (exemplo simplificado)
MATCH (u:User {id: "user123"})-[t:LISTENED_TO]->(s:Song)<-[r:LISTENED_TO]-(similar:User)
WITH similar, SUM(t.count * r.count) AS collabScore
MATCH (similar)-[:LISTENED_TO]->(rec:Song)
WHERE NOT (u)-[:LISTENED_TO]->(rec)

// Score baseado em conteÃºdo
WITH rec, collabScore
MATCH (rec)-[:BELONGS_TO]->(g:Genre)<-[:BELONGS_TO]-(liked:Song)<-[:LISTENED_TO]-(u)
WITH rec, collabScore, COUNT(liked) AS contentScore

// Combina scores (70% colaborativo, 30% conteÃºdo)
RETURN rec.title AS recommendation, 
       (collabScore * 0.7 + contentScore * 0.3) AS hybridScore
ORDER BY hybridScore DESC
LIMIT 10;
```

---

#### **3. Tratamento de Cold Start**  
Para usuÃ¡rios novos sem histÃ³rico de escuta:  
```cypher
// Recomenda mÃºsicas populares
MATCH (s:Song)<-[l:LISTENED_TO]-(u:User)
RETURN s.title AS recommendation, SUM(l.count) AS popularity
ORDER BY popularity DESC
LIMIT 10;

// Ou recomenda baseado em artistas/genres explÃ­citos (se disponÃ­vel)
MATCH (u:User {id: "new_user"})-[:FOLLOWS]->(a:Artist)-[:CREATED]->(s:Song)
RETURN s.title AS recommendation;
```

---

#### **4. Passos para ImplementaÃ§Ã£o**  
1. **ImportaÃ§Ã£o de Dados:**  
   - Carregue usuÃ¡rios, mÃºsicas, artistas e gÃªneros via CSV/JSON usando `LOAD CSV` ou APIs.  
   - Registre interaÃ§Ãµes (ex.: `LISTENED_TO`) com contagens e timestamps.

2. **ConfiguraÃ§Ã£o do GDS (Graph Data Science Library):**  
   - Instale o plugin GDS para algoritmos otimizados (Node Similarity, PageRank).  
   - Projete subgrafos para anÃ¡lise (ex.: `collabGraph`).

3. **Consulta em Tempo Real:**  
   - Para um usuÃ¡rio-alvo, execute as consultas acima conforme o contexto (com/sim histÃ³rico).  
   - Combine resultados de mÃºltiplas estratÃ©gias com pesos ajustÃ¡veis.

4. **AtualizaÃ§Ã£o ContÃ­nua:**  
   - Atualize o grafo com novas interaÃ§Ãµes em tempo real ou por lotes.  
   - Reexecute algoritmos do GDS periodicamente para manter recomendaÃ§Ãµes relevantes.

---

#### **5. OtimizaÃ§Ãµes**  
- **Cache:** Armazene recomendaÃ§Ãµes frequentes em Redis ou no prÃ³prio Neo4j.  
- **Personalized PageRank:** Use o GDS para ranquear mÃºsicas com base na proximidade do usuÃ¡rio no grafo:  
  ```cypher
  CALL gds.pageRank.stream("musicGraph", {
    maxIterations: 20,
    sourceNodes: [gds.util.asNode("user123")]
  })
  YIELD nodeId, score
  WITH gds.util.asNode(nodeId) AS song, score
  WHERE song:Song AND NOT (:User {id: "user123"})-[:LISTENED_TO]->(song)
  RETURN song.title, score
  ORDER BY score DESC
  LIMIT 10;
  ```
- **PonderaÃ§Ã£o por Tempo:** DÃª mais peso a mÃºsicas ouvidas recentemente usando `lastListen`.

---

**Resultado:** Um sistema flexÃ­vel que adapta recomendaÃ§Ãµes conforme o comportamento do usuÃ¡rio, combinando a riqueza de relacionamentos do Neo4j com tÃ©cnicas clÃ¡ssicas de machine learning. ğŸµğŸš€
